#!/bin/bash
# vim: sw=4:sts=4:et

. $(dirname "$0")/common-functions

usage()
{
    echo "Check whether a sha or reference is missing in any branch"
    echo
    echo "Usage: ${0##*/} [-c] [-t] sha reference..."
    echo
    echo "Parameters:"
    echo "	hash: hash of the upstream commit associated with the patch"
    echo "	reference: reference to be checked, e.g. bsc#123456 and/or CVE-XXXX-YYYY"
    echo "	-a: show actions which has to be done (shows only top level branches)"
    echo "	-c: check also cve branches"
    echo "	-h: help"
    echo "	-p: show progress when checking branches"
}

branch=
bprefix=
sha=
references=

cve=
top_level=

branches_conf="$(fetch_branches)"

tmpdir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
trap 'rm -rf "$tmpdir"' EXIT

state_file="$tmpdir/sha-state"
merged_state_file="$tmpdir/meged-sha-state"
actions_file="$tmpdir/actions"

print_sha_state()
{
    local msg="$@"

    if [ -n "$show_progress" ] ; then
	echo -n "."
    else
	verbose_msg "$msg"
    fi

    echo "$msg" >> "$state_file"
}

check_sha_ref_state()
{
    local branch="$1"
    local sha="$2"
    local ref="$3"

    [ -z "$branch" ] && fail "check_sha_ref_state: No branch provided"
    [ -z "$ref" ] && fail "check_sha_ref_state: No ref provided"
    [ -z "$sha" ] && fail "check_sha_ref_state: No sha provided"

    msg_prefix="$branch:$sha"

    local base=$(branch_base_ver $branch)

    patch=$(sha_to_patch_in_branch "$sha" "$branch")

    # Already merged upstream?
    if sha_merged_in_upstream_tag "$sha" "$base" ; then
	print_sha_state "$msg_prefix:nope"
	return
    fi

    # Does the patch exist and has the reference?
    if [ -n "$patch" ] ; then
	if patch_has_reference_in_branch "$patch" "$ref" "$branch" ; then
	    print_sha_state "$msg_prefix:ok"
	else
	    print_sha_state "$msg_prefix:missing_ref:$ref"
	fi

	return
    fi

    # Do we need to backport it because of the Fixes tag?
    if sha_has_git_fixes "$sha" "$base" ; then
	local affected_by_git_fixes="$(sha_affected_by_git_fixes "$sha" "$base" "$branch")"

	if [ -n "$affected_by_git_fixes" ] ; then
	    print_sha_state "$msg_prefix:missing_patch:$affected_by_git_fixes"
	else
	    print_sha_state "$msg_prefix:nope"
	fi

	return
    fi

    # missing git fixes
    print_sha_state "$msg_prefix:might_be_missing:$ref"
}

merge_one_state()
{
    local branch="$1"
    local sha="$2"
    local state="$3"

    local references=
    local ref=

    [ -z "$branch" ] && fail "merge_one_state: No branch provided"
    [ -z "$sha" ] && fail "merge_one_state: No sha provided"
    [ -z "$state" ] && fail "merge_one_state: No state provided"

    if [ "$state" == "missing_ref" -o "$state" == "might_be_missing" -o "$state" == "missing_patch" ] ; then
	for ref in $(grep "^$branch:$sha:$state:" "$state_file" | cut -d: -f4 | sort -u) ; do
	    if [ -z "references" ] ; then
		references="$ref"
	    else
		references="$references $ref"
	    fi
	done
	echo "$branch:$sha:$state:$references" >> "$merged_state_file"
    else
	echo "$branch:$sha:$state" >> "$merged_state_file"
    fi
}

merge_states()
{
    local branch=
    local sha=
    local state=

    for branch in $(cat "$state_file" | cut -d: -f1 | sort -u) ; do
	for sha in $(grep "^$branch:" "$state_file" | cut -d: -f2 | sort -u) ; do
	    for state in $(grep "^$branch:$sha:" "$state_file" | cut -d: -f3 | sort -u) ; do
		merge_one_state "$branch" "$sha" "$state"
	    done
	done
    done
}

print_action()
{
    local branch="$1"
    local sha="$2"
    local state="$3"
    local refereces="$@"

    [ -z "$branch" ] && fail "print_action: No branch provided"
    [ -z "$sha" ] && fail "print action: No sha provided"
    [ -z "$state" ] && fail "print action: No state provided"
    [ -z "$references" ] && fail "print action: No references provided"

    action=
    case "$state" in
	missing_patch)
	    action="$branch: MANUAL: backport $sha $references"
	    ;;
	might_be_missing)
	    action="$branch: MANUAL: might be missing $sha $references"
	    ;;
	missing_ref)
	    action="$branch: RUN: add-missing-reference $sha $references"
	    ;;
	nope)
	    [ -n "$verbose_mode" ] && action="%branch: NOPE: no problema for $sha $references"
	    ;;
	ok)
	    [ -n "$verbose_mode" ] && action="%branch: NOPE: up-to-date $sha $references"
	    ;;
	*)
	    fail "print_action: Unknown action: $action"
	    ;;
    esac


    if [ -n "$action" ] ; then
	if [ ! -e "$actions_file" ] ; then
	    # first action
	    echo "ACTION NEEDED!"
	    touch "$actions_file"
	fi

	push_list_msg "action" "$action"

	# FIXME: Could the action ever be duplicated?
	if ! grep -q "^$action$" "$actions_file" ; then
	    echo "$action"
	    echo "$action" >> "actions_file"
	fi
    fi
}

find_and_print_toplevel_actions()
{
    local branch="$1"
    local action_parameters=
    local merge_branch=
    local mb_line=
    local line=
    local merge_found=

    [ -z "$branch" ] && fail "find_and_print_toplevel_actions: No branch provided"

    grep "^$branch:" "$merged_state_file" | \
	while read line ; do
	    for merge_branch in $(print_merge_branches $branches_conf $branch) ; do

		# branch name might include '/', e.g. cve/linux-4.12
		mb_line=$(echo -n "$line" | sed -e "s|^$branch:|$merge_branch:|")

		# ignore the state when the same change is needed in a merge branch
		if grep -q "^$mb_line$" "$merged_state_file" ; then
		    merge_found=1
		fi

	    done

	    if [ -z "$merge_found" ] ; then
		# split line into parameters
		print_action ${line//:/ }
	    fi
	done
}

show_summary()
{
    local problems=

    if grep -q -e "missing_ref" "$state_file" ; then
	problems="missing referece"
    fi
    if grep -q -e "missing_patch" "$state_file" ; then
	[ -n "$problems" ] && problems="$problems and "
	problems="${problems}missing patch"
    fi

    if [ -z "$problems" ] ; then
	echo "Summary: OK"
    else
	echo "Summary: ACTION_NEEDED ($problems)"
	cat "$merged_state_file"
    fi
}

check_cve=
verbose_mode=
show_progress=

while getopts "ahcvp" OPT
do
    case $OPT in
	h)
	    usage
	    exit
	    ;;
	c)
	    check_cve="-c"
	    ;;
	a)
	    show_actions=1
	    ;;
	v)
	    verbose_mode=1
	    ;;
	p)
	    show_progress=1
	    ;;
    esac
done

shift "$(($OPTIND-1))"

[ -n "$verbose_mode" ] && show_progress=

sha="$1"
if [ -z "$sha" ] ; then
    echo "No commit provided"
    usage
    exit 1
fi
shift

references="$@"
if [ -z "$references" ] ; then
    echo "Error: missing reference"
    usage
    exit 1
fi

for ref in $references ; do
    for_each_build_branch $check_cve "$branches_conf" check_sha_ref_state "$sha" "$ref"
done

# newline after the dots
[ -n "$show_progress" ] && echo

# The state of each branch is checked separately for each referece.
# Merge same states for each branch.
merge_states

if [ -n "$show_actions" ] ; then
    for_each_build_branch  $check_cve "$branches_conf" find_and_print_toplevel_actions
else
    show_summary
fi
